
#include "rclcpp/rclcpp.hpp"
#include "mujoco/mujoco.h"

#include "mujoco_ros2_control/mujoco_ros2_control.hpp"
#include "mujoco_ros2_control/mujoco_rendering.hpp"


class MuJoCoRos2ControlNode: public rclcpp::Node {
public:
  MuJoCoRos2ControlNode(const rclcpp::NodeOptions &options)
  : rclcpp::Node("mujoco_ros2_control_node", options) {
    RCLCPP_INFO_STREAM(this->get_logger(), "Initializing mujoco_ros2_control node...");

    auto model_path = this->get_parameter("mujoco_model_path").as_string();
    this->load_model(model_path);
    this->init_data();
  }

  ~MuJoCoRos2ControlNode() {
    renderer->close();

    // free MuJoCo model and data
    mj_deleteData(mujoco_data);
    mj_deleteModel(mujoco_model);
  }

  void main_loop() {
    // run main loop, target real-time simulation and 60 fps rendering
    while (rclcpp::ok() && !renderer->is_close_flag_raised()) {
      // advance interactive simulation for 1/60 sec
      //  Assuming MuJoCo can simulate faster than real-time, which it usually can,
      //  this loop will finish on time for the next frame to be rendered at 60 fps.
      //  Otherwise add a cpu timer and exit this loop when it is time to render.
      mjtNum simstart = mujoco_data->time;
      while (mujoco_data->time - simstart < 1.0/60.0) {
        ros2_controller->update();
      }
      renderer->update();
    }
  }

private:
  void load_model(std::string model_path) {
    // load and compile model
    char error[1000] = "Could not load binary model";
    if (std::strlen(model_path.c_str())>4 && !std::strcmp(model_path.c_str()+std::strlen(model_path.c_str())-4, ".mjb")) {
      mujoco_model = mj_loadModel(model_path.c_str(), 0);
    } else {
      mujoco_model = mj_loadXML(model_path.c_str(), 0, error, 1000);
    }
    if (!mujoco_model) {
      mju_error("Load model error: %s", error);
    }

    RCLCPP_INFO_STREAM(this->get_logger(), "Mujoco model has been successfully loaded !");
  }
  void init_data() {
    // make data
    mujoco_data = mj_makeData(mujoco_model);

    // initialize mujoco control
    node = std::shared_ptr<rclcpp::Node>(this);
    ros2_controller = new mujoco_ros2_control::MujocoRos2Control(node, mujoco_model, mujoco_data);
    ros2_controller->init();
    RCLCPP_INFO_STREAM(node->get_logger(), "Mujoco ros2 controller has been successfully initialized !");

    // initialize mujoco redering
    renderer = mujoco_ros2_control::MujocoRendering::get_instance();
    renderer->init(node, mujoco_model, mujoco_data);
    RCLCPP_INFO_STREAM(node->get_logger(), "Mujoco rendering has been successfully initialized !");
  }

  mjModel* mujoco_model;
  mjData* mujoco_data;
  rclcpp::Node::SharedPtr node; // this

  mujoco_ros2_control::MujocoRos2Control *ros2_controller;
  mujoco_ros2_control::MujocoRendering *renderer;
};


// main function
int main(int argc, const char** argv) {

  rclcpp::init(argc, argv);

  rclcpp::NodeOptions options;
  options.automatically_declare_parameters_from_overrides(true);
  auto node = std::make_shared<MuJoCoRos2ControlNode>(options);

  rclcpp::executors::MultiThreadedExecutor executor;
  auto sim_worker_thread = std::make_unique<std::thread>([&executor, &node]() {
      executor.add_node(node);
      executor.spin();
      executor.remove_node(node);
  });

  node->main_loop();

  sim_worker_thread->join();
  rclcpp::shutdown();

  return 1;
}
